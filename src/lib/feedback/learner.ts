import fs from 'fs-extra';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { UXEnhancementSummary } from '../persrm/types';
import { SimulatedFlowResult, UserFlow } from './simulator';

/**
 * Represents learning data for a component
 */
export interface ComponentLearningData {
  componentId: string;
  componentName: string;
  firstAnalyzedAt: string;
  lastAnalyzedAt: string;
  improvementRate: number; // 0-1 scale
  scoreHistory: {
    timestamp: string;
    score: number;
    flowId?: string;
  }[];
  stagnantSince?: string; // When component improvement plateaued
  optimizationAttempts: number;
  suggestions: LearnerSuggestion[];
}

/**
 * Represents a suggestion generated by the learner
 */
export interface LearnerSuggestion {
  id: string;
  timestamp: string;
  suggestionType: 'optimization' | 'variant' | 'reassess' | 'focus'; 
  description: string;
  priority: 'low' | 'medium' | 'high';
  implementedAt?: string;
  result?: string;
}

/**
 * Tracks UX improvement over time and provides insights
 */
export class UXLearner {
  private learningDataPath: string;
  private componentData: Map<string, ComponentLearningData> = new Map();
  private flowResults: Map<string, SimulatedFlowResult[]> = new Map();
  
  constructor(dataPath?: string) {
    // Default path is in the project root
    this.learningDataPath = dataPath || path.resolve(process.cwd(), 'persrm-learning-data.json');
    this.loadData();
  }
  
  /**
   * Add results from a simulated flow to the learning data
   * @param results Array of simulation results
   * @param flow The user flow that was simulated
   * @param componentSummaries Map of component summaries used in the simulation
   */
  public addFlowResults(
    results: SimulatedFlowResult[], 
    flow: UserFlow,
    componentSummaries: { [componentName: string]: UXEnhancementSummary }
  ): void {
    // Store flow results
    this.flowResults.set(flow.id, results);
    
    // Update component learning data based on results
    const componentsInFlow = new Set<string>(flow.steps.map(step => step.component));
    
    componentsInFlow.forEach(componentName => {
      const summary = componentSummaries[componentName];
      if (!summary) return;
      
      // Get or create learning data for this component
      let learningData = this.componentData.get(componentName);
      
      if (!learningData) {
        learningData = {
          componentId: summary.id || uuidv4(),
          componentName,
          firstAnalyzedAt: new Date().toISOString(),
          lastAnalyzedAt: new Date().toISOString(),
          improvementRate: 0,
          scoreHistory: [],
          optimizationAttempts: 0,
          suggestions: []
        };
        this.componentData.set(componentName, learningData);
      } else {
        learningData.lastAnalyzedAt = new Date().toISOString();
      }
      
      // Average flow score as a measure of component performance
      const avgScore = results.reduce((sum, result) => sum + result.overallScore, 0) / results.length;
      
      // Add to score history
      learningData.scoreHistory.push({
        timestamp: new Date().toISOString(),
        score: avgScore,
        flowId: flow.id
      });
      
      // Calculate improvement rate
      this.updateImprovementRate(learningData);
      
      // Check for stagnation
      this.checkForStagnation(learningData);
      
      // Generate suggestions if needed
      this.generateSuggestions(learningData);
    });
    
    // Save updated data
    this.saveData();
  }
  
  /**
   * Get learning data for a specific component
   * @param componentName Name of the component
   * @returns Learning data for the component or undefined if not found
   */
  public getComponentLearningData(componentName: string): ComponentLearningData | undefined {
    return this.componentData.get(componentName);
  }
  
  /**
   * Get all component learning data
   * @returns Array of all component learning data
   */
  public getAllComponentData(): ComponentLearningData[] {
    return Array.from(this.componentData.values());
  }
  
  /**
   * Get components that haven't shown improvement recently
   * @param runs Number of runs to consider for stagnation (default: 3)
   * @returns Array of stagnant component data
   */
  public getStagnantComponents(runs: number = 3): ComponentLearningData[] {
    return this.getAllComponentData().filter(component => {
      if (component.stagnantSince) return true;
      
      // Check if there are enough data points
      if (component.scoreHistory.length < runs) return false;
      
      // Get the last N scores
      const recentScores = component.scoreHistory
        .slice(-runs)
        .map(history => history.score);
      
      // Calculate standard deviation to see if there's meaningful change
      const mean = recentScores.reduce((sum, score) => sum + score, 0) / recentScores.length;
      const variance = recentScores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / recentScores.length;
      const stdDev = Math.sqrt(variance);
      
      // If standard deviation is very low, consider it stagnant
      return stdDev < 1.0;
    });
  }
  
  /**
   * Tracks a component optimization and updates learning data
   * @param componentName Name of the component
   * @param optimizationType Type of optimization applied
   * @returns Updated learning data
   */
  public trackOptimization(
    componentName: string,
    optimizationType: 'optimization' | 'variant' | 'reassess'
  ): ComponentLearningData | undefined {
    const learningData = this.componentData.get(componentName);
    if (!learningData) return undefined;
    
    // Update optimization attempts
    learningData.optimizationAttempts += 1;
    
    // Mark suggestions as implemented if they match the optimization type
    learningData.suggestions.forEach(suggestion => {
      if (suggestion.suggestionType === optimizationType && !suggestion.implementedAt) {
        suggestion.implementedAt = new Date().toISOString();
      }
    });
    
    // Reset stagnation if we're applying new optimizations
    learningData.stagnantSince = undefined;
    
    this.saveData();
    return learningData;
  }
  
  /**
   * Updates the improvement rate for a component based on score history
   * @param learningData The component learning data to update
   */
  private updateImprovementRate(learningData: ComponentLearningData): void {
    const history = learningData.scoreHistory;
    
    if (history.length < 2) {
      learningData.improvementRate = 0;
      return;
    }
    
    // Sort history by timestamp
    const sortedHistory = [...history].sort((a, b) => 
      new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
    );
    
    // Calculate score changes over time
    let totalImprovement = 0;
    let totalPossibleImprovement = 0;
    
    for (let i = 1; i < sortedHistory.length; i++) {
      const prevScore = sortedHistory[i - 1].score;
      const currScore = sortedHistory[i].score;
      
      // Only count positive improvements
      const improvement = Math.max(0, currScore - prevScore);
      
      // Max possible improvement would be going from prev score to 100
      const possibleImprovement = 100 - prevScore;
      
      totalImprovement += improvement;
      totalPossibleImprovement += possibleImprovement;
    }
    
    // Calculate improvement rate (how much of possible improvement was achieved)
    if (totalPossibleImprovement > 0) {
      learningData.improvementRate = totalImprovement / totalPossibleImprovement;
    } else {
      learningData.improvementRate = 0;
    }
  }
  
  /**
   * Checks if a component's improvement has stagnated
   * @param learningData The component learning data to check
   */
  private checkForStagnation(learningData: ComponentLearningData): void {
    const history = learningData.scoreHistory;
    
    // Need at least 3 data points to detect stagnation
    if (history.length < 3) return;
    
    // Get last 3 scores
    const lastThreeScores = history.slice(-3).map(h => h.score);
    
    // If scores are not improving significantly
    const isImproving = lastThreeScores[2] > lastThreeScores[0] + 3; // 3 point improvement threshold
    
    // Check if scores are very similar (plateau)
    const maxDiff = Math.max(...lastThreeScores) - Math.min(...lastThreeScores);
    const isPlateaued = maxDiff < 2; // Less than 2 point difference
    
    if (!isImproving && isPlateaued) {
      // Mark as stagnant if not already
      if (!learningData.stagnantSince) {
        learningData.stagnantSince = new Date().toISOString();
      }
    } else {
      // Reset stagnation if improving
      learningData.stagnantSince = undefined;
    }
  }
  
  /**
   * Generates suggestions for a component based on learning data
   * @param learningData The component learning data to generate suggestions for
   */
  private generateSuggestions(learningData: ComponentLearningData): void {
    const history = learningData.scoreHistory;
    const recentSuggestions = learningData.suggestions.filter(s => !s.implementedAt)
    
    // Don't add duplicate suggestions
    if (recentSuggestions.length > 0) return;
    
    // Generate suggestions based on patterns
    if (learningData.stagnantSince) {
      // If stagnant for a while and previous optimization attempts
      if (learningData.optimizationAttempts > 0) {
        // Suggest trying a variant approach
        learningData.suggestions.push({
          id: uuidv4(),
          timestamp: new Date().toISOString(),
          suggestionType: 'variant',
          description: `Try a different approach for ${learningData.componentName} as current optimizations have plateaued.`,
          priority: 'medium'
        });
      } else {
        // Suggest first optimization
        learningData.suggestions.push({
          id: uuidv4(),
          timestamp: new Date().toISOString(),
          suggestionType: 'optimization',
          description: `Component ${learningData.componentName} needs initial optimization.`,
          priority: 'high'
        });
      }
    }
    
    // If score history shows regression
    if (history.length >= 2) {
      const latest = history[history.length - 1].score;
      const previous = history[history.length - 2].score;
      
      if (latest < previous - 5) { // 5 point regression threshold
        learningData.suggestions.push({
          id: uuidv4(),
          timestamp: new Date().toISOString(),
          suggestionType: 'reassess',
          description: `Component ${learningData.componentName} has regressed. Re-evaluate recent changes.`,
          priority: 'high'
        });
      }
    }
    
    // If consistently low-scoring (under 50)
    const avgRecentScore = history.slice(-3).reduce((sum, h) => sum + h.score, 0) / 
      Math.min(3, history.length);
    
    if (avgRecentScore < 50) {
      learningData.suggestions.push({
        id: uuidv4(),
        timestamp: new Date().toISOString(),
        suggestionType: 'focus',
        description: `Focus efforts on ${learningData.componentName} as it consistently scores below 50.`,
        priority: 'high'
      });
    }
  }
  
  /**
   * Loads learning data from disk
   */
  private loadData(): void {
    try {
      if (fs.existsSync(this.learningDataPath)) {
        const data = fs.readJSONSync(this.learningDataPath);
        
        // Load component data
        if (data.components && Array.isArray(data.components)) {
          data.components.forEach((component: ComponentLearningData) => {
            this.componentData.set(component.componentName, component);
          });
        }
        
        // Load flow results
        if (data.flowResults && typeof data.flowResults === 'object') {
          Object.entries(data.flowResults).forEach(([flowId, results]) => {
            this.flowResults.set(flowId, results as SimulatedFlowResult[]);
          });
        }
      }
    } catch (error) {
      console.error('Error loading learning data:', error);
      // Initialize with empty data
      this.componentData = new Map();
      this.flowResults = new Map();
    }
  }
  
  /**
   * Saves learning data to disk
   */
  private saveData(): void {
    try {
      const data = {
        components: Array.from(this.componentData.values()),
        flowResults: Object.fromEntries(this.flowResults.entries())
      };
      
      fs.ensureDirSync(path.dirname(this.learningDataPath));
      fs.writeJSONSync(this.learningDataPath, data, { spaces: 2 });
    } catch (error) {
      console.error('Error saving learning data:', error);
    }
  }
}

// Singleton instance
const learner = new UXLearner();

/**
 * Adds flow simulation results to the learning system
 * @param results Simulation results to add
 * @param flow The user flow that was simulated
 * @param componentSummaries Map of component summaries
 */
export function addFlowResults(
  results: SimulatedFlowResult[],
  flow: UserFlow,
  componentSummaries: { [componentName: string]: UXEnhancementSummary }
): void {
  return learner.addFlowResults(results, flow, componentSummaries);
}

/**
 * Get components that haven't shown improvement after multiple optimization attempts
 * @param minRuns Minimum number of runs to consider (default: 3)
 * @returns Array of stagnant components
 */
export function getStagnantComponents(minRuns: number = 3): ComponentLearningData[] {
  return learner.getStagnantComponents(minRuns);
}

/**
 * Gets learning data for all components
 * @returns Array of component learning data
 */
export function getAllComponentData(): ComponentLearningData[] {
  return learner.getAllComponentData();
}

/**
 * Gets learning data for a specific component
 * @param componentName Name of the component
 * @returns Learning data for the component
 */
export function getComponentLearningData(componentName: string): ComponentLearningData | undefined {
  return learner.getComponentLearningData(componentName);
}

/**
 * Tracks an optimization applied to a component
 * @param componentName Name of the component
 * @param optimizationType Type of optimization applied
 * @returns Updated learning data
 */
export function trackOptimization(
  componentName: string,
  optimizationType: 'optimization' | 'variant' | 'reassess'
): ComponentLearningData | undefined {
  return learner.trackOptimization(componentName, optimizationType);
}

/**
 * Creates a learning baseline for a component
 * @param componentName Name of the component to create a baseline for
 * @param summary UX enhancement summary for the component
 * @returns Created learning data
 */
export function createLearningBaseline(
  componentName: string,
  summary: UXEnhancementSummary
): ComponentLearningData {
  const data: ComponentLearningData = {
    componentId: summary.id || uuidv4(),
    componentName,
    firstAnalyzedAt: new Date().toISOString(),
    lastAnalyzedAt: new Date().toISOString(),
    improvementRate: 0,
    scoreHistory: [{
      timestamp: new Date().toISOString(),
      score: summary.overallScore
    }],
    optimizationAttempts: 0,
    suggestions: []
  };
  
  learner.addFlowResults([], { 
    id: uuidv4(),
    name: 'Baseline',
    description: 'Initial baseline measurement',
    steps: [],
    expectedTotalDuration: 0,
    requiredStepsToComplete: []
  }, { [componentName]: summary });
  
  return data;
} 